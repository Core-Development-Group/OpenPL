
// C++ Colour Class (removed for refactoring to C)

namespace pl {
    namespace math {

        struct Colour {
            Colour() : Colour(PL_COLOUR_WHITE) {}

            Colour(PLuchar _r, PLuchar _g, PLuchar _b, PLuchar _a = 255) : r(_r), g(_g), b(_b), a(_a) {}

            Colour(PLint _r, PLint _g, PLint _b, PLint _a = 255) :
                    Colour((PLuchar) _r, (PLuchar) _g, (PLuchar) _b, (PLuchar) _a) {}

            Colour(PLfloat _r, PLfloat _g, PLfloat _b, PLfloat _a = 1) :
                    r((PLuchar) (_r * 255)),
                    g((PLuchar) (_g * 255)),
                    b((PLuchar) (_b * 255)),
                    a((PLuchar) (_a * 255)) {}

            PLuchar r, g, b, a;

            PLbool operator==(Colour in) const { return ((r == in.r) && (g == in.g) && (b == in.b) && (a == in.a)); }

            Colour operator*(Colour in) { return Colour(r * in.r, g * in.g, b * in.b, a * in.a); }

            Colour operator/(Colour in) { return Colour(r / in.r, g / in.g, b / in.b, a / in.a); }

            void PL_INLINE Set(PLfloat _r, PLfloat _g, PLfloat _b, PLfloat _a = 1) {
                r = (PLuchar) (_r * 255);
                g = (PLuchar) (_g * 255);
                b = (PLuchar) (_b * 255);
                a = (PLuchar) (_a * 255);
            }

            void PL_INLINE Clear() {
                r = 0;
                g = 0;
                b = 0;
                a = 0;
            }
        };

    }
}

// C++ Quaternion Class (removed for refactoring to C)

#ifdef __cplusplus

typedef struct PLQuaternion {
    PLQuaternion(PLfloat a, PLfloat b, PLfloat c, PLfloat d) : x(a), y(b), z(c), w(d) {}

    PLQuaternion(PLfloat a, PLfloat b, PLfloat c) : x(a), y(b), z(c), w(0) {}

    PLQuaternion() : x(0), y(0), z(0), w(0) {}

    PLfloat x, y, z, w;

    void operator=(PLQuaternion a) {
        x = a.x;
        y = a.y;
        z = a.z;
        w = a.w;
    }

    void operator*=(PLfloat a) {
        x *= a;
        y *= a;
        z *= a;
        w *= a;
    }

    void operator*=(PLQuaternion a) {
        x *= a.x;
        y *= a.y;
        z *= a.z;
        w *= a.w;
    }

    PLbool operator==(PLQuaternion a) const {
        return ((x == a.x) && (y == a.y) && (z == a.z) && (w == a.w));
    }

    PLQuaternion operator*(PLfloat a) {
        return PLQuaternion(x * a, y * a, z * a, w * a);
    }

    PLQuaternion operator*(PLQuaternion a) {
        return PLQuaternion(x * a.x, y * a.y, z * a.z, w * a.w);
    }

    void PL_INLINE Set(PLfloat a, PLfloat b, PLfloat c, PLfloat d) {
        x = a;
        y = b;
        z = c;
        w = d;
    }

    void PL_INLINE Set(PLfloat a, PLfloat b, PLfloat c) {
        x = a;
        y = b;
        z = c;
    }

    void PL_INLINE Clear() {
        x = 0;
        y = 0;
        z = 0;
        w = 0;
    }

    const PL_INLINE PLchar *String() {
        static PLchar s[32] = {0};
        snprintf(s, 32, "%i %i %i %i", (PLint) x, (PLint) y, (PLint) z, (PLint) w);
        return s;
    }

    PLfloat PL_INLINE Length() {
        return std::sqrt((x * x + y * y + z * z + w * w));
    }

    PLQuaternion PL_INLINE Scale(PLfloat a) {
        return PLQuaternion(x * a, y * a, z * a, w * a);
    }

    PLQuaternion PL_INLINE Inverse() {
        return PLQuaternion(-x, -y, -z, w);
    }

    PLQuaternion PL_INLINE Normalize() {
        PLfloat l = Length();
        if (l) {
            float i = 1 / l;
            return Scale(i);
        }
    }
} PLQuaternion;

#endif
